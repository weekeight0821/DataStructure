# 数据结构
## 入门篇
### 时间复杂度
#### 定义
代码执行的时间;实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度.
#### 分析方法
1. 只关注循环次数最多的一段代码  
2. 加法法则，总的复杂度等于量级最大的那段代码的复杂度  
3. 乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积  
#### 分类
##### 1. 最好情况时间复杂度
在最理想的情况下，执行这段代码的时间复杂度
##### 2. 最坏情况时间复杂度
在最糟糕的情况下，执行这段代码的时间复杂度
##### 3. 平均情况时间复杂度
用代码在所有情况下执行的次数的加权平均值表示;也就期望值,所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度
##### 4. 均摊时间复杂度
###### 备注:
平均和平摊基本就是一个概念，平摊是特殊的平均。在分析时间复杂度是O(1)还是O(n)的时候最简单就是凭感觉出现O(1)的次数远大于出现O(n)出现的次数，那么平均平摊时间复杂度就是O(1)
### 空间复杂度
#### 定义：代码的存储空间;表示算法的执行时间与数据规模之间的增长关系，所以，也叫作渐进空间复杂度.
## 基础篇
### 线性表
#### 数组
##### 定义：具有一组连续的内存空间，用来存储一组具有相同类型的数据
##### 操作 
查找：a[i]_address = base_address + i * data_type_size  
插入：  
删除：
##### 优点：数组支持随机访问，根据下标随机访问的世界复杂度为O(1)
##### 问题：组下标为什么从0开始，而不是从1开始呢？
如果下标从0开始：  
a[k]_address = base_address + k * type_size  
如果下标从1开始：  
a[k]_address = base_address + (k-1)*type_size  
对比两个公式，如果下标从1开始，每次随机访问数组元素都多了一次减法运算，对于 CPU来说，就多一次减法指令
#### 链表
#### 栈
#### 队列
